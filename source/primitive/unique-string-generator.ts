import { isString, isNumber, isArray } from '../general/type-checking';

/**
 * Returns a random string generator function that never returns the same string twice unless every possible string has
 * been generated, at which point the same set of strings will be produced again in the same order.
 *
 * For custom formatting and output control, see {@link UniqueStringGenerator.Formatted}.
 *
 * @example
 * ```ts
* // Generate strings of length 8 containing characters from the default set (UniqueStringGenerator.LettersAndDigits):
* const generator1 = UniqueStringGenerator(8);
* const foo1 = generator1(); // e.g. "aF5b3cD7"
* const bar1 = generator1(); // e.g. "1e2F3g4"
* const baz1 = generator1(); // e.g. "h5I6j7K"
*
* // Generate strings of length 12 containing characters from a custom set:
* const generator2 = UniqueStringGenerator(12, 'ABCDEF');
* const foo2 = generator2(); // e.g. "BDEBACDDBFED"
* const bar2 = generator2(); // e.g. "FACFEDFEDFED"
* const baz2 = generator2(); // e.g. "BACBDEBACBDE"
* ```
*
* @todo After all possible strings have been generated, regenerate state to change the set of strings that will be
* produced on the next round of generations.
*/
export function UniqueStringGenerator (length: number, chars: string = UniqueStringGenerator.LettersAndDigits) {
 const state = new UniqueStringGenerator.State(length, chars);
 return () => state.next();
}
export type UniqueStringGenerator = () => string;
export namespace UniqueStringGenerator {
 /**
  * Returns a random string generator function that produces strings according to a custom format. Note that each time
  * the generator function is called, every inner generator function is called independently, which means that any
  * guarantees of uniqueness exist only at the segment level, not at the level of the entire output string. Consider the
  * characteristics of each segment generator when assessing the level of uniqueness that can be expected from the
  * output string.
  *
  * @param segments An array of segment specifiers used to produced a sequence of segments that will be concatenated to
  * form an output string. Each segment specifier can be either a static string, a number (indicating the length of a
  * random segment of characters from the default character set), a tuple of a length and a custom character set (these
  * will be passed as arguments to the {@link UniqueStringGenerator} construction function), or a custom random string
  * generator function.
  * @example
  * ```ts
  * const generator = UniqueStringGenerator.Formatted(
  *  'prefix--', // A static prefix string
  *  [4, UniqueStringGenerator.Digits], // A segment of 4 random digits
  *  '[', // A static opening square bracket
  *  [2, '!@#$%^&*'], // A segment of 2 random characters from a custom character set
  *  ']', // A static closing square bracket
  *  6, // A segment of 6 random characters from the default character set
  *  '--', // A static double hyphen
  *  () => Math.random() > 0.5 ? 'short' : 'reallyquitelong', // A segment whose output is generated by a custom function
  * );
  * const value = generator(); // e.g. "prefix--3841[!#]aF5b3c--reallyquitelong"
  */
 export function Formatted (...segments: (UniqueStringGenerator | string | number | [length: number, chars: string])[]): UniqueStringGenerator {
   const generators = segments.map(s => isString(s) ? () => s : isNumber(s) ? UniqueStringGenerator(s) : isArray(s) ? UniqueStringGenerator(s[0], s[1]) : s);
   return () => generators.map(g => g()).join('');
 }

 export const Digits = '0123456789';
 export const UpperCaseLetters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
 export const LowerCaseLetters = 'abcdefghijklmnopqrstuvwxyz';
 export const Letters = `${UpperCaseLetters}${LowerCaseLetters}`;
 export const LettersAndDigits = `${Letters}${Digits}`;

 // The approach for this generator is inspired by mechanical counter displays which traditionally function such that
 // each increment flips over the first digit, then wraps around and increments the next digit, and so on. What I'm
 // doing here is as follows:
 // 1. For each character index from 0 to length-1 (where length refers to the length of the strings that this
 //    generator will produce each time it is asked to produce another random string), produce an "index string" that
 //    is a random arrangement of all of the characters in the input character set. This string will represent a
 //    sequence of all of the possible characters for a specific index in strings that the generator will produce. I'll
 //    refer to any string that the generator will produce as an "output string".
 // 2. Imagine each index string as a vertical column of characters on a strip of paper. We'll place each strip of
 //    paper side by side so that reading from left to right gives us N random output strings, where N is the number of
 //    characters in the input character set.
 // 3. A cursor is maintained starting at 0. It is like a small black arrow, initially positioned so that it is
 //    pointing at the bottom character of the leftmost paper strip. Incrementing the cursor will move the arrow up to
 //    the next row index. When incrementing past the top, we'll wrap around back to the bottom and at that point do a
 //    little shuffling work to make sure the next set of generated strings is unique relative to previous sets.
 // 4. When asked to generate a new string, we return the string for the row of characters at the current cursor
 //    position, then we increment the cursor.
 // 5. If incrementing the cursor wraps it back to the start, we'll "rotate" the starting position of the first paper
 //    strip so that the set of output strings is now different to what it was previously.

 export class State {
   constructor (length: number, chars: string) {
     const chars_array = Array.from(chars);
     const columns: string[][] = [];
     const rowCursors: number[] = [];
     for (let i = 0; i < length; ++i) {
       rowCursors.push(0);
       const array = chars_array.map(c => ({ c, r: Math.random() }));
       array.sort((a, b) => a.r - b.r);
       columns.push(array.map(a => a.c));
     }
     this.#length = length;
     this.#chars = chars;
     this.#columns = columns;
     this.#rowCursors = rowCursors;
   }
   readonly #length: number;
   readonly #chars: string;
   readonly #columns: string[][];
   readonly #rowCursors: number[];

   next () {
     const rowCursor = this.#rowCursors[0]++;
     const output = this.#columns.map(array => array[rowCursor]).join('');
     if (rowCursor + 1 === this.#chars.length) this.rotate(0);
     return output;
   }

   private rotate (columnIndex: number) {
     this.#rowCursors[columnIndex] = 0;
     const column = this.#columns[columnIndex];
     const firstChar = column[0];
     for (let i = 0; i < column.length - 1; ++i) {
       column[i] = column[i + 1];
     }
     column[column.length - 1] = firstChar;

     let nextColumnIndex = columnIndex + 1;
     if (nextColumnIndex === this.#length) nextColumnIndex = 0;
     const nextColumnRowCursor = this.#rowCursors[nextColumnIndex]++;
     if (nextColumnRowCursor + 1 === this.#chars.length) {
       this.rotate(nextColumnIndex);
     }
   }
 }
}
