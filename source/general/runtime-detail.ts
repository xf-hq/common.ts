import Case from 'case';
import { isDefined, isNumber, isUndefined } from './type-checking';

/**
 * Represents structured runtime metadata that can be attached to errors, logs or other diagnostics.
 *
 * @remarks
 * Use `RuntimeDetail` to capture both machine-readable discriminators and human-readable messaging for runtime events.
 * Create reusable domain constants to express logical scopes, then instantiate details for concrete situations. Prefer
 * providing structured `refs` payloads so downstream consumers can inspect rich context without parsing strings. For
 * example:
 *
 * ```ts
 * const ServicesDomain = new RuntimeDetail({ type: 'services', domain: AppDomain });
 *
 * function invalidRequest (issues: ValidationIssue[]) {
 *   return new RuntimeDetail({
 *     type: 'invalid-request-data',
 *     domain: ServicesDomain,
 *     refs: issues,
 *     formatDescription: (args) => `Request data is invalid: ${args.refs![0].message}`,
 *   });
 * }
 *
 * throw new DetailedError(invalidRequest(validationIssues));
 * ```
 *
 * Best practices:
 * - Define domain instances once and reuse them to ensure qualified types remain stable. For example:
 *
 * ```ts
 * export const AppDomain = new RuntimeDetail({ type: 'app' });
 * export const ServicesDomain = new RuntimeDetail({
 *   type: 'services',
 *   domain: AppDomain,
 * });
 * export const DataDomain = new RuntimeDetail({
 *   type: 'data',
 *   domain: AppDomain,
 * });
 * ```
 *
 * - Provide `formatLabel`/`formatDescription` callbacks when the message should reflect dynamic `refs` content.
 *
 * ```ts
 * export function parameterMissing (param: string) {
 *   return new RuntimeDetail({
 *     type: 'parameter-missing',
 *     domain: ServicesDomain,
 *     refs: { param },
 *     formatDescription: (args) => `Required parameter '${args.refs!.param}' is missing.`,
 *   });
 * }
 * ```
 *
 * - Inspect `qualifiedType` or `isInDomain` when categorising or routing diagnostics downstream. A logging pipeline,
 *   for instance, can bucket metrics by `detail.qualifiedType` while an error handler can check
 *   `detail.isInDomain('data')` to decide whether the issue should be surfaced to operations tooling or translated into
 *   a client-facing response.
 *
 * @typeParam TType - Discriminator type used to identify the runtime condition.
 * @typeParam TRefs - Structured payload attached to the detail for additional context.
 */
export class RuntimeDetail<TType extends string | number = string | number, TRefs = unknown> {
  constructor (private readonly _args: RuntimeDetail.Args<TType, TRefs>) {}
  #label: string;
  #description: string;
  #qualifiedType: string;
  #qualifiedDomain: { value: string | undefined };

  /**
   * The type of this detail.
   *
   * @returns The discriminator value supplied when the detail was created.
   */
  get type (): TType { return this._args.type; }
  /**
   * Indicates a general implementation domain that can be used to help interpret and disambiguate the `type`, `refs`
   * and so on. This should generally be used in contexts where some kind of category label or other scope identifier is
   * needed (e.g. for tagging a console message with a prefix indicating the name of the area the console message
   * relates to).
   *
   * @returns The parent domain `RuntimeDetail`, if one was provided.
   */
  get domain (): RuntimeDetail | undefined { return this._args.domain; }
  /**
   * The human-readable label for the detail.
   *
   * @returns A cached label, either explicitly supplied or generated from the type.
   */
  get label (): string { return this._args.label ?? (this.#label ??= this._label()); }
  /**
   * The human-readable description for the detail.
   *
   * @returns A cached description, either explicitly supplied or generated via formatting rules.
   */
  get description (): string { return this._args.description ?? (this.#description ??= this._description()); }
  /**
   * Structured contextual references for the detail.
   *
   * @returns The value passed in the `refs` argument, if present.
   */
  get refs (): TRefs | undefined { return this._args.refs; }
  /**
   * Additional detail instances that contributed to or sourced this detail.
   *
   * @returns An array of source details, if one was provided.
   */
  get sources (): RuntimeDetail[] | undefined { return this._args.sources; }

  /**
   * Indicates whether a domain association was specified.
   */
  get hasDomain (): boolean { return isDefined(this._args.domain); }
  /**
   * Indicates whether the label was auto-generated.
   */
  get hasAutogeneratedLabel (): boolean { return isUndefined(this._args.label) && isUndefined(this._args.formatLabel); }
  /**
   * Indicates whether the description was auto-generated.
   */
  get hasAutogeneratedDescription (): boolean { return isUndefined(this._args.description) && isUndefined(this._args.formatDescription); }

  /**
   * The type qualified with the full domain hierarchy.
   *
   * @returns A colon-delimited domain/type sequence or the raw type if no domain is assigned.
   */
  get qualifiedType (): string { return this.#qualifiedType ??= (this.hasDomain ? `${this.qualifiedDomain}:${this.type}` : String(this.type)); }
  /**
   * The colon-delimited domain path leading to this detail.
   *
   * @returns The full domain string or `undefined` when the detail has no domain.
   */
  get qualifiedDomain (): string | undefined {
    if (isDefined(this.#qualifiedDomain)) return this.#qualifiedDomain.value;
    this.#qualifiedDomain = { value: undefined };
    if (!this.hasDomain) return;
    let domain = this.domain;
    if (isUndefined(domain)) return;
    const parts: (string | number)[] = [];
    do {
      parts.unshift(domain.type);
      domain = domain.domain;
    }
    while (isDefined(domain));
    return this.#qualifiedDomain.value = parts.join(':');
  }

  /**
   * Determines whether this detail belongs to a specific domain lineage.
   *
   * @param type - The domain type to check for.
   * @returns `true` if the detail exists within the supplied domain hierarchy; otherwise `false`.
   */
  isInDomain (type: string): boolean {
    if (!this.hasDomain) return false;
    if (this.domain!.type === type) return true;
    return this.domain!.isInDomain(type);
  }

  private _label (): string {
    if (isDefined(this._args.label)) return this._args.label;
    if (isDefined(this._args.formatLabel)) return this._args.formatLabel(this._args, this);
    const type = this._args.type;
    return (
      isNumber(type) ? `Error Type ${type}` :
      type.includes(' ') ? type : // If a space is present, we can't reliably reason about it, so we treat it as human-readable
      Case.title(type) // Convert to title case
    );
  }

  private _description (): string {
    if (isDefined(this._args.description)) return this._args.description;
    if (isDefined(this._args.formatDescription)) return this._args.formatDescription(this._args, this);
    return `No description of this available.`;
  }
}
export namespace RuntimeDetail {
  /**
   * Arguments required to construct a `RuntimeDetail` instance.
   *
   * @typeParam TType - Discriminator type used to identify the runtime condition.
   * @typeParam TRefs - Structured payload attached to the detail for additional context.
   */
  export interface Args<TType extends string | number, TRefs> {
    /**
     * Discriminator value describing the runtime condition.
     */
    readonly type: TType;
    /**
     * Optional parent domain used to scope the detail.
     */
    readonly domain?: RuntimeDetail;
    /**
     * Optional human-readable label.
     */
    readonly label?: string;
    /**
     * Optional human-readable description.
     */
    readonly description?: string;
    /**
     * Structured contextual payload associated with the detail.
     */
    readonly refs?: TRefs;
    /**
     * Source details that influenced or produced this detail.
     */
    readonly sources?: RuntimeDetail[];
    /**
     * Optional callback that generates a label when none is supplied.
     *
     * @param args - The arguments originally provided to the constructor.
     * @param detail - The detail instance being constructed.
     * @returns A human-readable label.
     */
    formatLabel? (args: Args<TType, TRefs>, detail: RuntimeDetail<TType, TRefs>): string;
    /**
     * Optional callback that generates a description when none is supplied.
     *
     * @param args - The arguments originally provided to the constructor.
     * @param detail - The detail instance being constructed.
     * @returns A human-readable description.
     */
    formatDescription? (args: Args<TType, TRefs>, detail: RuntimeDetail<TType, TRefs>): string;
  }
}
