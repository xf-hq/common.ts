import Case from 'case';
import { isDefined, isNumber, isUndefined } from './type-checking';

export class RuntimeDetail<TType extends string | number = string | number, TRefs = unknown> {
  constructor (private readonly _args: RuntimeDetail.Args<TType, TRefs>) {}
  #label: string;
  #description: string;
  #qualifiedType: string;
  #qualifiedDomain: { value: string | undefined };

  /**
   * The type of this detail.
   */
  get type (): TType { return this._args.type; }
  /**
   * Indicates a general implementation domain that can be used to help interpret and disambiguate the `type`, `refs`
   * and so on. This should generally be used in contexts where some kind of category label or other scope identifier is
   * needed (e.g. for tagging a console message with a prefix indicating the name of the area the console message
   * relates to).
   */
  get domain (): RuntimeDetail | undefined { return this._args.domain; }
  get label (): string { return this._args.label ?? (this.#label ??= this._label()); }
  get description (): string { return this._args.description ?? (this.#description ??= this._description()); }
  get refs (): TRefs | undefined { return this._args.refs; }
  get sources (): RuntimeDetail[] | undefined { return this._args.sources; }

  get hasDomain (): boolean { return isDefined(this._args.domain); }
  get hasAutogeneratedLabel (): boolean { return isUndefined(this._args.label) && isUndefined(this._args.formatLabel); }
  get hasAutogeneratedDescription (): boolean { return isUndefined(this._args.description) && isUndefined(this._args.formatDescription); }

  get qualifiedType (): string { return this.#qualifiedType ??= (this.hasDomain ? `${this.qualifiedDomain}:${this.type}` : String(this.type)); }
  get qualifiedDomain (): string | undefined {
    if (isDefined(this.#qualifiedDomain)) return this.#qualifiedDomain.value;
    this.#qualifiedDomain = { value: undefined };
    if (!this.hasDomain) return;
    let domain = this.domain;
    if (isUndefined(domain)) return;
    const parts: (string | number)[] = [];
    do {
      parts.unshift(domain.type);
      domain = domain.domain;
    }
    while (isDefined(domain));
    return this.#qualifiedDomain.value = parts.join(':');
  }

  isInDomain (type: string): boolean {
    if (!this.hasDomain) return false;
    if (this.domain!.type === type) return true;
    return this.domain!.isInDomain(type);
  }

  private _label (): string {
    if (isDefined(this._args.label)) return this._args.label;
    if (isDefined(this._args.formatLabel)) return this._args.formatLabel(this._args, this);
    const type = this._args.type;
    return (
      isNumber(type) ? `Error Type ${type}` :
      type.includes(' ') ? type : // If a space is present, we can't reliably reason about it, so we treat it as human-readable
      Case.title(type) // Convert to title case
    );
  }

  private _description (): string {
    if (isDefined(this._args.description)) return this._args.description;
    if (isDefined(this._args.formatDescription)) return this._args.formatDescription(this._args, this);
    return `No description of this available.`;
  }
}
export namespace RuntimeDetail {
  export interface Args<TType extends string | number, TRefs> {
    readonly type: TType;
    readonly domain?: RuntimeDetail;
    readonly label?: string;
    readonly description?: string;
    readonly refs?: TRefs;
    readonly sources?: RuntimeDetail[];
    formatLabel? (args: Args<TType, TRefs>, detail: RuntimeDetail<TType, TRefs>): string;
    formatDescription? (args: Args<TType, TRefs>, detail: RuntimeDetail<TType, TRefs>): string;
  }
}
